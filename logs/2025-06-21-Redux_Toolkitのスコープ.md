# Redux Toolkitのスコープ

- **学習日**: 2025/06/21
- **学習時間**: 20分
- **効果実感**: 3/5
- **効果の種類**: 理解が深まった

## 内容

redux toolkitを使用する場合、アプリケーションの全体をreduxを使用した仕様に実装するのが一般的なのでしょうか
例えば、userやunitなどのデータも状態としてグローバル管理しつつ、バックエンドからのデータ取得などもreduxのthunkを使用して取得するようにするのでしょうか


はい、そのご認識は非常に的確です。Redux Toolkit（RTK）を導入する場合、**アプリケーションの主要な状態をReduxで一元管理し、非同期処理（データ取得など）もThunk（またはSagaなど）を使ってReduxのフローに乗せるのが一般的**です。

なぜそうするのか、そしてそのメリット・デメリットについて解説します。

---

### なぜReduxで「すべて」を管理するのか？

#### 1. 唯一の信頼できる情報源 (Single Source of Truth)

*   **目的**: アプリケーションのどこで、いつ、なぜ、どのように状態が変化したのかを、すべてReduxで追跡できるようにするためです。
*   **具体例**:
    *   `user`情報、`unit`一覧、選択中の`unit`詳細、`logs`一覧などの**サーバーから取得したデータ（サーバーキャッシュ）**。
    *   UIの状態（例: 「ダークモードかどうか」「モーダルが開いているか」など）。
*   **メリット**:
    *   **予測可能性**: データの流れが「Action → Reducer」に統一されるため、状態変化が予測しやすくなります。
    *   **デバッグの容易さ**: Redux DevToolsを使えば、過去に`dispatch`されたActionを遡って、どのActionが原因で状態がどう変わったかを時系列で確認できます。これは非常に強力なデバッグツールです。

#### 2. 非同期処理の抽象化

*   **目的**: コンポーネントからAPI通信などの非同期ロジックを分離し、コンポーネントをUIの表示という本来の責務に集中させるためです。
*   **Thunkを使う場合**:
    *   コンポーネントは`dispatch(fetchUnits())`のように、ただThunk Actionを`dispatch`するだけです。
    *   ローディング状態の管理、成功時のデータ格納、失敗時のエラーハンドリングといった**非同期処理のライフサイクル管理**は、すべてReduxのSlice（`extraReducers`）側で完結します。
*   **メリット**:
    *   **関心の分離**: UIコンポーネントは、APIのエンドポイントやHTTPヘッダー、エラー処理の詳細を知る必要がなくなります。
    *   **再利用性の向上**: 同じデータ取得ロジック（Thunk）を、複数の異なるコンポーネントから再利用できます。
    *   **テストの容易さ**: UIとは独立して、ThunkやReducerの純粋なロジックをテストできます。

---

### 実装のイメージ

もし現在のプロジェクトの主要なデータをReduxで管理すると、ストアの`state`は以下のようになります。

```typescript
// store.tsのRootStateのイメージ
type RootState = {
  auth: { // 認証状態
    user: User | null;
    session: Session | null;
    loading: boolean;
  };
  units: { // ユニット一覧
    items: Unit[];
    status: 'idle' | 'loading' | 'succeeded' | 'failed';
  };
  currentUnit: { // 表示中のユニット詳細
    data: UnitDetail | null;
    status: 'idle' | 'loading' | 'succeeded' | 'failed';
    logs: { // ユニットに紐づくログ
      items: Log[];
      status: 'idle' | 'loading' | 'succeeded' | 'failed';
    };
    comments: { // ユニットに紐づくコメント
      items: Comment[];
      status: 'idle' | 'loading' | 'succeeded' | 'failed';
    }
  };
  // ...その他のグローバルなUI状態など
}
```

コンポーネントは、これらの状態を`useAppSelector`で購読し、必要なデータを表示します。データの再取得や更新が必要な場合は、`useAppDispatch`で対応するThunkを`dispatch`します。

### ただし、すべてをReduxに入れる必要はない（例外）

このアプローチは非常に強力ですが、何でもかんでもReduxに入れると逆に冗長になるケースもあります。

**Reduxで管理しなくても良い状態の例:**

*   **コンポーネントのローカルな状態**:
    *   制御されたフォーム（`<input>`）の値。入力のたびにReduxを更新するのは冗長なことが多いです（`useState`や`useReducer`で十分）。
    *   特定のコンポーネント内だけで完結するUIの状態（例: アコーディオンの開閉状態）。
*   **サーバーキャッシュ管理に特化したライブラリ**:
    *   **React Query (TanStack Query)** や **SWR** は、サーバーからのデータ取得、キャッシュ、再検証の管理に特化しています。
    *   これらのライブラリとReduxを**併用する**アプローチも非常に人気があります。
        *   **Redux**: グローバルなUI状態、認証情報など、クライアント側で「真」の状態。
        *   **React Query/SWR**: サーバーデータのキャッシュ。ローディングやエラー状態の管理をこれらに任せる。
    *   この併用パターンは、Reduxのボイラープレート（お決まりのコード）を減らしつつ、それぞれのライブラリの長所を活かせるため、多くの大規模プロジェクトで採用されています。

### 結論

ご質問への直接的な回答としては、
「はい、Redux Toolkitを導入する場合、**アプリケーションの主要なデータ（サーバーデータ含む）と非同期処理をReduxの仕組みで一元管理するのが一般的**です。」

しかし、それは唯一の正解ではありません。
プロジェクトの要件に応じて、**React Query/SWRと併用**し、Reduxの役割をクライアント状態の管理に限定するという、よりモダンで効率的なアーキテクチャを選択することも可能です。

まずは基本となる「すべてをReduxで管理する」アプローチを理解した上で、プロジェクトの特性に合わせて最適な道具を選択していくのが良いでしょう。